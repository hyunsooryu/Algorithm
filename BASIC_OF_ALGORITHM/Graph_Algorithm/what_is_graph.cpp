#include <iostream>
#include <vector>
using namespace std;

//인접행렬이 좋은점
//1. u -> v가 존재하는지 안하는지 찾을 때 1만에 찾을수있다
//2. v -> u로 가는것도 한번에 찾아볼 수 있다.
//간선이 존재하냐. 그 역방향 간선이 존재하냐. 이러한것들은 인접행렬로 좋다.

//인접리스트는 u의 차수만큼입니다.
//인접 리스트는 공간복잡도가 정말 줄어들게 됩니다. 양방향이라하면, E^2 만큼만입니다.
//인접리스트는 실제 정점의 차수만큼만 입니다.

//완전그래프? 모든 정점사이에 간선이 존재하는 경우가있습니다. V(V - 1) / 2 인접리스트가 비효율적입니다.
//******************************************************************************************************************
//그래프 탐색의 목적은 무엇입니까? DFS / BFS 임의의 시작점 X에서 시작하여, 모든 정점을 한번씩!! 만 방문하는것이 목표입니다.
//******************************************************************************************************************

//DFS 깊이 우선 탐색 STACK, RECURSIVE

//DFS의 시간복잡도 는 
//인접행렬을 사용한다면 (V^2)
//인접리스트를 사용한다면 (V + E) E는 간선의 개수입니다.
//BFS 너비 우선 탐색 QUEUE

//DFS / BFS -> 목표는 같다.
//BFS의 시간복잡도 는
//인접행렬을 사용한다면 ()

//BFS는 무조건 Q에 넣을때 방문했다고 처리를 해야합니다..
//BFS도 V + E 만큼의 시간이걸립니다.
//인접행렬을 사용한다면 V^2이걸립니다.


//연결요소란 무엇일까?

//Connected Component입니다.




int main() {






	return 0;
}